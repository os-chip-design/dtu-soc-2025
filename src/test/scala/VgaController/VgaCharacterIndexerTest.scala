import chisel3._
import chiseltest._
import org.scalatest.flatspec.AnyFlatSpec

import VgaConfig._

class VgaCharacterIndexerTest extends AnyFlatSpec with ChiselScalatestTester {

  behavior of "VgaCharacterIndexer (Combinational Inputs)"

  // Helper function to poke inputs and check outputs for combinational logic
  def checkIndexer(
      c: VgaCharacterIndexer,
      px: Int,
      py: Int,
      hAct: Boolean,
      vAct: Boolean,
      expXIdx: Int,
      expYIdx: Int,
      expAddr: Int
  ): Unit = {
    c.io.pixelX.poke(px.U)
    c.io.pixelY.poke(py.U)
    c.io.hActive.poke(hAct.B)
    c.io.vActive.poke(vAct.B)
    c.io.xCharIndex.expect(expXIdx.U)
    c.io.yCharIndex.expect(expYIdx.U)
    c.io.charBaseAddr.expect(expAddr.U)
  }

  // Test cases generated by Google Gemini, but verified by hand
  it should "calculate indices and address correctly for first pixel" in {
    test(new VgaCharacterIndexer) { c =>
      // Pixel (0, 0) -> Char (0, 0), Index (0, 0), Prefetch Addr 0
      checkIndexer(c, 0, 0, true, true, 0, 0, 0)
    }
  }

  it should "calculate indices and address correctly within a character" in {
    test(new VgaCharacterIndexer) { c =>
      // Pixel (5, 10) -> Char (0, 0), Index (5, 10), Prefetch Addr 0
      // HCharGridPos = floor(5/8) = 0
      // VCharGridPos = floor(10/16) = 0
      // isLastPixel = false
      // BaseAddr = 0 * 80 + 0 = 0
      checkIndexer(c, 5, 10, true, true, 5, 10, 0)
    }
  }

  it should "prefetch address at horizontal character boundary" in {
    test(new VgaCharacterIndexer) { c =>
      // Pixel (7, 10) -> Char (0, 0), Index (7, 10), Prefetch Addr 1 (for char 1,0)
      // HCharGridPos = floor(7/8) = 0
      // VCharGridPos = floor(10/16) = 0
      // isLastPixel = true, nextHCharGridPos = 1
      // BaseAddr = 0 * 80 + 1 = 1
      checkIndexer(c, 7, 10, true, true, 7, 10, 1)
    }
  }

  it should "calculate address correctly at start of next character" in {
    test(new VgaCharacterIndexer) { c =>
      // Pixel (8, 10) -> Char (1, 0), Index (0, 10), Prefetch Addr 1
      // HCharGridPos = floor(8/8) = 1
      // VCharGridPos = floor(10/16) = 0
      // isLastPixel = false
      // BaseAddr = 0 * 80 + 1 = 1
      checkIndexer(c, 8, 10, true, true, 0, 10, 1)
    }
  }

  it should "calculate indices and address for a character not in the first row/col" in {
    test(new VgaCharacterIndexer) { c =>
      // Pixel (90, 18) -> Char (11, 1), Index (2, 2), Prefetch Addr 91
      // HCharGridPos = floor(90/8) = 11
      // VCharGridPos = floor(18/16) = 1
      // isLastPixel = false
      // BaseAddr = 1 * 80 + 11 = 91
      checkIndexer(c, 90, 18, true, true, 2, 2, 91)
    }
  }

  it should "prefetch address correctly at end-of-line character boundary" in {
    test(new VgaCharacterIndexer) { c =>
      // Pixel (639, 10) -> Char (79, 0), Index (7, 10), Prefetch Addr 0 (wrap H)
      // HCharGridPos = floor(639/8) = 79
      // VCharGridPos = floor(10/16) = 0
      // isLastPixel = true, nextHCharGridPos = 0 (wrap around)
      // BaseAddr = 0 * 80 + 0 = 0
      checkIndexer(c, 639, 10, true, true, 7, 10, 0)
    }
  }

  it should "output defaults when not in active area" in {
    test(new VgaCharacterIndexer) { c =>
      // Test hActive = false
      checkIndexer(c, 10, 10, false, true, 0, 0, 0)
      // Test vActive = false
      checkIndexer(c, 10, 10, true, false, 0, 0, 0)
      // Test both false
      checkIndexer(c, 10, 10, false, false, 0, 0, 0)
      // Test boundary cases where coords might be active but signal isn't
      // Note: With combinational inputs, pixelX/Y will be outside display range
      // when hActive/vActive are false, but the logic should still default to 0.
      checkIndexer(
        c,
        H_DISPLAY,
        10,
        false,
        true,
        0,
        0,
        0
      )
      checkIndexer(
        c,
        10,
        V_DISPLAY,
        true,
        false,
        0,
        0,
        0
      )
    }
  }
}
